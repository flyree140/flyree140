<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>å¤©åœ°åŠ«Â·æˆ°æ£‹ï¼ˆæœ€çµ‚æ•´åˆç‰ˆï¼‰</title>
<style>
:root{--cell:60px;--w:12;--h:10}
body{margin:0;background:#0e1217;color:#e6edf3;font-family:system-ui,"Noto Sans TC","Microsoft JhengHei",sans-serif}
header{padding:10px 14px;border-bottom:1px solid #263040;background:#10161f;display:flex;gap:10px;align-items:center;justify-content:space-between}
h1{margin:0;font-size:16px}
main{display:grid;grid-template-columns:auto 400px;gap:10px;padding:10px}
#board{width:calc(var(--cell)*var(--w));height:calc(var(--cell)*var(--h));position:relative;border:1px solid #263040;border-radius:10px;background:
linear-gradient(#263040 1px,transparent 1px) 0 0/var(--cell) var(--cell),
linear-gradient(90deg,#263040 1px,transparent 1px) 0 0/var(--cell) var(--cell),#0b0f14}
.unit{position:absolute;width:var(--cell);height:var(--cell);display:grid;place-items:center;border-radius:10px;font-weight:700;cursor:pointer;user-select:none}
.ally{background:#173a66;border:1px solid #6fb1ff}
.enemy{background:#5a1f1f;border:1px solid #ff8b8b}
.dead{opacity:.35;filter:grayscale(1);pointer-events:none}
.badge{position:absolute;top:2px;right:4px;font-size:12px;padding:2px 6px;border-radius:999px;background:#0b0f14;border:1px solid #3a475c}
.hpbar{position:absolute;bottom:2px;left:4px;right:4px;height:6px;background:#1b2431;border-radius:4px;overflow:hidden}
.hp{height:100%;background:#71e38e}
.sel{box-shadow:0 0 0 3px #86e1ff66 inset}
.tile{position:absolute;width:var(--cell);height:var(--cell);pointer-events:none}
.move{outline:2px solid rgba(80,180,255,.85);background:rgba(80,180,255,.12)}
.atk{outline:2px solid rgba(255,120,120,.95);background:rgba(255,80,80,.12)}
.blk{position:absolute;left:0;top:0;width:100%;height:100%;background:#2a3344;box-shadow:inset 0 0 0 2px #3e4a62;border-radius:8px}
.terrain-fire{position:absolute;left:0;top:0;width:100%;height:100%;background:linear-gradient(135deg,rgba(255,120,0,.18),rgba(255,0,0,.18));box-shadow:inset 0 0 0 2px rgba(255,120,0,.5);border-radius:8px}

/* å³å´æ¬„ */
aside{border:1px solid #263040;background:#0b0f14;border-radius:10px;display:flex;flex-direction:column;overflow:hidden}
.panel{padding:10px 10px 0;display:flex;flex-wrap:wrap;gap:6px}
.chip{border:1px solid #334156;border-radius:999px;padding:4px 8px;font-size:12px}
.section{padding:10px;border-top:1px solid #263040}
.section h3{margin:0 0 6px 0;font-size:13px;letter-spacing:.5px;color:#9ecbff;display:flex;align-items:center;gap:6px}
.kv{display:flex;gap:6px;flex-wrap:wrap}
.kv .tag{border:1px solid #334156;background:#101829;padding:3px 8px;border-radius:8px;font-size:12px}
hr.sep{border:0;border-top:1px dashed #2b3a50;margin:8px 0}

/* Infoå¡ç‰‡ */
#info{padding:10px;border-top:1px solid #263040}
.info-card{border:1px solid #2a3a52;background:#0f1520;border-radius:10px;overflow:hidden}
.info-head{padding:10px 12px;background:linear-gradient(180deg,#0f1b2a,#0b111b);display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid #233044}
.info-head .name{font-weight:700}
.info-head .stat{font-size:12px;opacity:.9}
.info-body{padding:8px 12px}
.skill{padding:8px;border:1px solid #22304a;border-radius:8px;background:#0b111b;margin:6px 0}
.skill b{font-size:13px}
.skill .meta{font-size:12px;opacity:.85}
.soul{padding:8px;border:1px solid #42314a;background:#17111b;border-radius:8px;margin-top:8px}

/* å‹•ä½œåˆ—/ç´€éŒ„ */
#actions{display:flex;gap:6px;flex-wrap:wrap;padding:8px 10px;border-top:1px solid #263040}
.btn{background:#1a2330;border:1px solid #3a475c;color:#e6edf3;padding:7px 10px;border-radius:8px;cursor:pointer}
.btn:disabled{opacity:.5;cursor:not-allowed}
#actionBar{border-top:1px solid #263040;padding:8px 10px;display:flex;flex-direction:column;gap:6px}
.dot{padding:2px 8px;border:1px solid #334156;border-radius:999px;font-size:12px}
.dot.done{background:#213045;border-color:#3e6e9f}
.dot.foe{background:#3b2222;border-color:#9f3e3e}
#log{flex:1;padding:10px;overflow:auto;border-top:1px solid #263040;font-family:ui-monospace,Menlo,Consolas,monospace;max-height:220px}
#turn{padding:8px 10px;border-top:1px solid #263040;display:flex;justify-content:space-between;align-items:center}

/* modal/è¡¨æ ¼ */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center}
.card{background:#0f1520;border:1px solid #334156;border-radius:12px;min-width:980px;max-width:95vw}
.card h2{margin:0;padding:12px 14px;border-bottom:1px solid #334156;font-size:16px}
.card .body{padding:12px 14px}
table{width:100%;border-collapse:collapse}
th,td{border-bottom:1px solid #233044;padding:6px;font-size:13px;text-align:left;vertical-align:top}
select{background:#0b0f14;color:#e6edf3;border:1px solid #3a475c;border-radius:6px;padding:4px}
input[type=number]{width:70px;background:#0b0f14;color:#e6edf3;border:1px solid #3a475c;border-radius:6px;padding:4px}
.skills{display:flex;gap:4px;flex-wrap:wrap}
.small{font-size:12px;opacity:.8}
.bad{color:#ff9aa3}
.good{color:#9cffc2}
</style>
</head>
<body>
<header>
  <div style="display:flex;gap:10px;align-items:center">
    <h1>å¤©åœ°åŠ«Â·æˆ°æ£‹ï¼ˆæœ€çµ‚æ•´åˆç‰ˆï¼‰</h1>
    <button id="openSetup" class="btn">ç·¨éšŠ / åœ°åœ–è¨­å®š</button>
    <button id="toggleEdit" class="btn">åœ°å½¢ç·¨è¼¯ï¼šé—œ</button>
  </div>
  <div style="display:flex;gap:8px;align-items:center">
    <button id="reset" class="btn">é‡é–‹ä¸€å±€</button>
  </div>
</header>
<main>
  <div id="board" aria-label="grid board"></div>
  <aside>
    <div class="panel">
      <div class="chip">æ£‹ç›¤ï¼š<span id="sizeTag">12Ã—10</span></div>
      <div class="chip">ä½ ä»»é¸ä¸€éš» â†” æ•µæ–¹å‡ºæ‰‹ä¸€éš»</div>
      <div class="chip">å‰‹åˆ¶ Ã—1.25 ï¼ è¢«å‰‹ Ã—0.80</div>
    </div>
    <div class="panel">
      <div class="chip">å…‰â†’æš—â†’å¹½â†’å…‰</div>
      <div class="chip">é›·â†’å†°â†’ç«â†’é›·</div>
      <div class="chip">ç¥â–¶å†°é›·ç«ï¼›ç¥â—€å…‰æš—å¹½</div>
      <div class="chip">é­”â–¶å…‰æš—å¹½ï¼›é­”â—€å†°é›·ç«</div>
    </div>

    <!-- å³å´è§’è‰²è³‡è¨Š -->
    <div id="info" class="section"></div>

    <div id="actions"></div>

    <div id="actionBar" class="section">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h3>ğŸ“œ è¡Œå‹•æ¢</h3>
        <button id="toggleLog" class="btn">æ”¶åˆç´€éŒ„</button>
      </div>
      <div class="small">æˆ‘æ–¹</div>
      <div id="barAllies" style="display:flex;flex-wrap:wrap;gap:6px"></div>
      <div class="small" style="margin-top:4px">æ•µæ–¹</div>
      <div id="barEnemies" style="display:flex;flex-wrap:wrap;gap:6px"></div>
    </div>

    <div id="log"></div>

    <div id="turn">
      <div>å›åˆï¼š<b id="roundNum">1</b>ï½œç¾åœ¨ï¼š<b id="turnWho">ç©å®¶</b></div>
      <div><button id="endAct" class="btn">çµæŸæœ¬æ¬¡è¡Œå‹•</button></div>
    </div>
  </aside>
</main>

<!-- ç·¨éšŠ / åœ°åœ–è¨­å®š -->
<div class="modal" id="setup">
  <div class="card">
    <h2>ç·¨éšŠ / åœ°åœ–è¨­å®šï¼ˆå¥—ç”¨å¾Œé‡é–‹ï¼‰</h2>
    <div class="body">
      <div style="display:flex;gap:16px;align-items:center;margin-bottom:10px">
        <div>æ£‹ç›¤å¯¬ï¼š<input id="mapW" type="number" min="6" max="20" value="12"></div>
        <div>æ£‹ç›¤é«˜ï¼š<input id="mapH" type="number" min="6" max="20" value="10"></div>
        <button id="clearBlocks" class="btn">æ¸…ç©ºéšœç¤™</button>
        <button id="randomBlocks" class="btn">éš¨æ©Ÿéšœç¤™</button>
      </div>
      <table>
        <thead><tr><th>æ§½ä½</th><th>é™£ç‡Ÿ</th><th>ä¾†æº</th><th>è·æ¥­/è§’è‰²</th><th>å±¬æ€§</th><th>é­‚çŸ³ï¼ˆä¸‰æšï¼‰</th><th>æ”œå¸¶æŠ€èƒ½ï¼ˆæœ€å¤š3ï¼‰</th></tr></thead>
        <tbody id="setupRows"></tbody>
      </table>
      <div class="small" style="margin-top:6px">
        ã€Œä¾†æºã€å¯é¸ <b>è·æ¥­</b> æˆ– <b>è§’è‰²</b>ï¼›è§’è‰²çš„æŠ€èƒ½æ± ä»¥è©²è§’è‰²å®šç¾©ç‚ºæº–ã€‚<br>
        é­‚çŸ³ä½¿ç”¨ã€Œä¸‰æšã€å¥—è£æ•ˆæœï¼ˆç­‰åŒå·²è£æ»¿ 3 é¡†ï¼‰ã€‚
      </div>
      <div style="display:flex;gap:8px;justify-content:flex-end;margin-top:10px">
        <button id="randTeam" class="btn">éš¨æ©Ÿç·¨éšŠ</button>
        <button id="applyTeam" class="btn">å¥—ç”¨ & é–‹å§‹</button>
        <button id="closeSetup" class="btn">é—œé–‰</button>
      </div>
    </div>
  </div>
</div>

<script>
/* ===================== å¸¸é‡èˆ‡é¡è‰² ===================== */
let GRID_W=12, GRID_H=10;
document.documentElement.style.setProperty('--w', GRID_W);
document.documentElement.style.setProperty('--h', GRID_H);
const CELL=60;
const board=document.getElementById("board"), actions=document.getElementById("actions");
const logEl=document.getElementById("log"), turnEl=document.getElementById("turnWho"), sizeTag=document.getElementById("sizeTag"), roundEl=document.getElementById("roundNum");

let EDIT_MODE=false;
/* è¦å‰‡é è¨­é—œï¼ˆç§»å‹•èˆ‡è¡Œå‹•å¯åŒå›åˆçš†åšï¼‰â†’ ä½ ä¹‹å‰çš„é–‹é—œå·²ç§»é™¤ */
let RULE_MOVE_OR_ACT=false;

const ATTR=["å…‰","æš—","å¹½","é›·","å†°","ç«","ç¥","é­”"];
const ATTR_COLOR={å…‰:"#f6d44a",æš—:"#b390ff",å¹½:"#7fd0ff",é›·:"#79ff8a",å†°:"#a7e3ff",ç«:"#ff7a6e",ç¥:"#ffdca8",é­”:"#ffb3d1"};
const ADV=1.25, DIS=0.8;
const TRIAD1=["å…‰","æš—","å¹½"], TRIAD2=["é›·","å†°","ç«"];
const G1=new Set(TRIAD1), G2=new Set(TRIAD2);
function colorAttr(a){return ATTR_COLOR[a]||"#fff";}
function inside(x,y){return x>=0&&y>=0&&x<GRID_W&&y<GRID_H;}
function neighbors(x,y){return[{x:x+1,y},{x:x-1,y},{x,y:y+1},{x,y:y-1}].filter(p=>inside(p.x,p.y));}
function manhattan(a,b){return Math.abs(a.x-b.x)+Math.abs(a.y-b.y);}

/* ===================== å±¬æ€§å…‹åˆ¶ ===================== */
function triadRel(a,b){for(const T of [TRIAD1,TRIAD2]){const i=T.indexOf(a),j=T.indexOf(b);if(i>-1&&j>-1){if((i+1)%3===j)return 1;if((j+1)%3===i)return -1}}return 0}
function specialRel(a,b){
  if(a==="ç¥"){if(G2.has(b))return 1;if(G1.has(b))return -1;}
  if(a==="é­”"){if(G1.has(b))return 1;if(G2.has(b))return -1;}
  if(b==="ç¥"){if(G2.has(a))return -1;if(G1.has(a))return 1;}
  if(b==="é­”"){if(G1.has(a))return -1;if(G2.has(a))return 1;}
  return 0;
}
function elemMul(a,b){const r=triadRel(a,b)||specialRel(a,b);return r===1?ADV:r===-1?DIS:1}

/* ===================== åœ°å½¢/éšœç¤™/è¦–ç·š ===================== */
let blocks=[]; function initBlocks(){blocks=Array.from({length:GRID_H},()=>Array(GRID_W).fill(false));}
function isBlocked(x,y){return blocks[y]&&blocks[y][x];}
function toggleBlock(x,y){if(unitAt(x,y))return; blocks[y][x]=!blocks[y][x]; render();}
function drawBlocks(){for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++)if(isBlocked(x,y)){const d=document.createElement("div");d.style.left=`${x*CELL}px`;d.style.top=`${y*CELL}px`;d.className="tile";const b=document.createElement("div");b.className="blk";d.appendChild(b);board.appendChild(d);}}
function lineOfSight(ax,ay,bx,by){let x=ax,y=ay,dx=Math.abs(bx-ax),dy=Math.abs(by-ay),sx=ax<bx?1:-1,sy=ay<by?1:-1,err=dx-dy;
  while(!(x===bx&&y===by)){const e2=2*err;if(e2>-dy){err-=dy;x+=sx}if(e2<dx){err+=dx;y+=sy}if(x===bx&&y===by)break;if(isBlocked(x,y)||unitAt(x,y))return false;}return true}

/* ======= å¯æŒçºŒåœ°å½¢ï¼šç‚ç„ ======= */
let terrains=[]; // {x,y,type:'fire',turns}
function addTerrain(x,y,type,turns){ if(!inside(x,y) || isBlocked(x,y)) return; terrains.push({x,y,type,turns}); }
function decayTerrains(){ terrains.forEach(t=>t.turns--); terrains=terrains.filter(t=>t.turns>0); }
function drawTerrains(){
  for(const t of terrains){ const d=document.createElement("div"); d.className="tile"; d.style.left=`${t.x*CELL}px`; d.style.top=`${t.y*CELL}px`;
    if(t.type==='fire'){ const f=document.createElement("div"); f.className="terrain-fire"; d.appendChild(f); }
    board.appendChild(d);
  }
}
function terrainAt(x,y,type){ return terrains.find(t=>t.x===x && t.y===y && t.type===type); }

/* ===================== å–®ä½èˆ‡ä½ˆé™£ ===================== */
let units=[], selected=null;
let round=1, phase="idle", skillLock=null;
// æœ¬å›åˆå°šå¯è¡Œå‹•åå–®
let alliesLeft=new Set(), enemiesLeft=new Set();

const slots=[
  {id:"A1", side:"ally", x:0,y:1},{id:"A2", side:"ally", x:1,y:0},{id:"A3", side:"ally", x:2,y:2},
  {id:"E1", side:"enemy",x:GRID_W-1,y:GRID_H-2},{id:"E2", side:"enemy",x:GRID_W-2,y:GRID_H-1},{id:"E3", side:"enemy",x:GRID_W-3,y:GRID_H-3},
];

/* è¡Œå‹•é–‹å§‹å¿«ç…§ï¼ˆä¾›åˆ‡æ›è§’è‰²æ™‚é‚„åŸï¼‰ */
function setActionStart(u){
  u.actionStart = { x: u.x, y: u.y };
  u.hasMoved = false;
  u.bonusMove = 0;
  if (!u.tags) u.tags = {};
  u.tags.moved2 = 0;
}
function rollbackToActionStart(u){
  if(!u || !u.actionStart) return;
  if(!u.hasActed){ // å°šæœªå®Œæˆæœ¬æ¬¡è¡Œå‹• â†’ é‚„åŸ
    const back=u.actionStart;
    u.x=back.x; u.y=back.y;
    u.hasMoved=false; u.bonusMove=0; u.tags.moved2=0;
    log(`${u.id} å–æ¶ˆæœªçµæŸç§»å‹•ï¼Œå›åˆ° (${u.x},${u.y})`);
  }
}

const JOBS={
  /* isChar: false ç‚ºè·æ¥­ï¼›true ç‚ºå…·åè§’è‰² */
  "éµè¡›":{isChar:false,move:3,min:1,max:1,hp:120,atk:24,def:18, skills:[
    {id:"guard",name:"å®ˆè­·å§¿æ…‹",type:"self",cd:3,desc:"è‡³ä¸‹å›åˆé–‹å§‹å—å‚·-50%",use:(u)=>{u.tags.guard=1;log(`${u.id} å®ˆè­·`); return true;}},
    {id:"taunt",name:"éµå£å˜²è«·",type:"self",cd:3,desc:"æœ¬å›åˆå˜²è«·",use:(u)=>{u.tags.taunt=1;log(`${u.id} å˜²è«·`); return true;}},
    {id:"block",name:"ç›¾æ“Š",type:"attack",cd:2,range:"job",desc:"100%ä¸¦ä½¿æ•µæ”»-30%ï¼ˆ1å›åˆï¼‰",use:(a,d)=>{d.tags.atkdown=1;hit(a,d,1)}}
  ]},
  "ä¿ å®¢":{isChar:false,move:3,min:1,max:1,hp:100,atk:30,def:12, skills:[
    {id:"combo",name:"é€£æ“Š",type:"attack",cd:3,range:"job",desc:"å…©æ®µå„80%",use:(a,d)=>{hit(a,d,0.8);if(!d.dead)hit(a,d,0.8)}},
    {id:"dashcut",name:"çªé€²æ–¬",type:"attack",cd:3,range:2,desc:"å°„ç¨‹2ï¼›è‹¥æœ¬æ¬¡ç§»å‹•â‰¥2æ ¼ï¼Œå‚·å®³+30%",use:(a,d)=>{const r=a.tags.moved2?1.3:1.0;hit(a,d,r)}},
    {id:"bleed",name:"ç ´ç”²ä¸€æ“Š",type:"attack",cd:3,range:"job",desc:"110%ä¸¦ä½¿æ•µé˜²-30%ï¼ˆ1å›åˆï¼‰",use:(a,d)=>{d.tags.defdown=1;hit(a,d,1.1)}},
    {id:"light",name:"è¼•èº«",type:"self",cd:3,needPhase:"move",desc:"æœ¬æ¬¡è¡Œå‹•çš„ç§»å‹•åŠ›+2",use:(u)=>{u.bonusMove=(u.bonusMove||0)+2;log(`${u.id} è¼•èº«+2`); return true;}}]},
  "å’’å¸«":{isChar:false,move:3,min:2,max:2,hp:90,atk:34,def:8, skills:[
    {id:"bolt",name:"éœœé›·å’’",type:"attack",cd:2,range:3,desc:"å°„ç¨‹3ï¼›æ³•è¡“120%",use:(a,d)=>{hit(a,d,1.2)}},
    {id:"blast",name:"è£‚å†°è¡“",type:"attack",cd:3,range:3,desc:"å°„ç¨‹3ï¼›æ³•è¡“140%",use:(a,d)=>{hit(a,d,1.4)}},
    {id:"slow",name:"å†°ç¸›",type:"attack",cd:3,range:3,desc:"80%ä¸¦ä½¿ç§»å‹•-1ï¼ˆ1å›åˆï¼‰",use:(a,d)=>{hit(a,d,0.8);d.tags.slow=1}},
    {id:"veil",name:"ç§˜è¡“è­·ç½©",type:"self",cd:3,desc:"ç²å¾—è­·ç›¾=æœ€å¤§ç”Ÿå‘½20%ï¼ˆ1å›åˆï¼‰",use:(u)=>{u.tags.shield=Math.floor(u.hpMax*0.2);log(`${u.id} è­·ç›¾+${u.tags.shield}`); return true;}}]},
  "ç¥ç”±":{isChar:false,move:3,min:2,max:2,hp:95,atk:18,def:10, skills:[
    {id:"heal",name:"å›æ˜¥",type:"heal",cd:2,range:2,val:40,desc:"å°„ç¨‹2ï¼›å›å¾©æˆ‘æ–¹å–®é«” 40",use:(a,t)=>{t.hp=Math.min(t.hpMax,t.hp+40);log(`${a.id} æ²»ç™‚ ${t.id} +40`);render(); return true;}},
    {id:"cleanse",name:"ç¥›ç—º",type:"self",cd:2,desc:"æ·¨åŒ–è‡ªèº«æ¸›ç›Š",use:(u)=>{u.tags={...u.tags,atkdown:0,defdown:0,slow:0,stun:0};log(`${u.id} æ·¨åŒ–`); return true;}},
    {id:"haste",name:"è¿…æ·",type:"self",cd:3,desc:"æœ¬å›åˆç§»å‹•åŠ›+1",use:(u)=>{u.bonusMove=(u.bonusMove||0)+1;log(`${u.id} è¿…æ·+1`); return true;}},
    {id:"rangeheal",name:"é å¼•å›æ˜¥",type:"heal",cd:3,range:3,val:30,desc:"å°„ç¨‹3ï¼›å›å¾©æˆ‘æ–¹å–®é«” 30",use:(a,t)=>{t.hp=Math.min(t.hpMax,t.hp+30);log(`${a.id} æ²»ç™‚ ${t.id} +30`);render(); return true;}}]},
  "ç¾½å£«":{isChar:false,move:3,min:2,max:2,hp:95,atk:28,def:10, skills:[
    {id:"pierce",name:"è²«é€šç®­",type:"attack",cd:3,range:2,desc:"å°„ç¨‹2ï¼›130%ï¼Œç„¡æ³•è¿‘æˆ°",use:(a,d)=>{hit(a,d,1.3)}},
    {id:"aim",name:"ç„æº–",type:"self",cd:2,desc:"æœ¬å›åˆé ç¨‹å¯ç„¡è¦–è¦–ç·š 1 æ¬¡",use:(u)=>{u.tags.aim=1;u.tags.aimCharges=1;log(`${u.id} ç„æº–`); return true;}},
    {id:"repel",name:"é©…æ•£ç®­",type:"attack",cd:3,range:2,desc:"å°„ç¨‹2ï¼›100%ï¼Œå…ˆç§»é™¤è­·ç›¾",use:(a,d)=>{d.tags.shield=0;hit(a,d,1.0)}},
    {id:"split",name:"æ•£å°„",type:"attack",cd:3,range:2,desc:"100%ï¼Œå¦å¤–å°ç›¸é„°æ•µ 90%",use:(a,d)=>{hit(a,d,0.9);const n=neighbors(d.x,d.y).map(p=>unitAt(p.x,p.y)).find(u=>u&&u.side!==a.side&&!u.dead);if(n)hit(a,n,0.9)}}]},
  "å¾¡é¢¨":{isChar:false,move:5,min:1,max:1,hp:90,atk:32,def:9, skills:[
    {id:"dash",name:"ç¬æ­¥",type:"dash",cd:3,needPhase:"move",desc:"æœªç§»å‹•æ™‚å¯ç”¨ï¼›æœ¬æ¬¡è¡Œå‹•ç§»å‹•åŠ›+2",use:(u)=>{u.bonusMove=(u.bonusMove||0)+2;log(`${u.id} ç¬æ­¥+2`); return true;}},
    {id:"assass",name:"èƒŒè¥²",type:"attack",cd:3,range:"job",desc:"120% è¿‘æˆ°",use:(a,d)=>{hit(a,d,1.2)}},
    {id:"smoke",name:"ç…™å¹•",type:"self",cd:3,desc:"æœ¬å›åˆå—å‚·-30%",use:(u)=>{u.tags.smoke=1;log(`${u.id} ç…™å¹•`); return true;}}]},
  "é¬¥å°‡":{isChar:false,move:4,min:1,max:1,hp:110,atk:34,def:12, skills:[
    {id:"berserk",name:"æˆ°æ„çˆ†ç™¼",type:"buff",cd:3,desc:"ä¸‹ä¸€æ“Šå‚·å®³+50%ä¸”ç ´ç”²50%ï¼ˆä¸€æ¬¡ï¼‰",use:(u)=>{u.tags.berserk={bonus:0.5,pierce:0.5,charges:1};log(`${u.id} æˆ°æ„ï¼`); return true;}},
    {id:"stun",name:"éœ‡æ“Š",type:"attack",cd:3,range:"job",desc:"110%ï¼Œä½¿ç›®æ¨™å¤±å»ä¸‹ä¸€æ¬¡ç§»å‹•",use:(a,d)=>{hit(a,d,1.1);d.tags.stun=1}},
    {id:"guardbreak",name:"ç¢ç”²",type:"attack",cd:3,range:"job",desc:"100%ï¼Œå…ˆç§»é™¤è­·ç›¾",use:(a,d)=>{d.tags.shield=0;hit(a,d,1.0)}}]},

  /* ===== è§’è‰²ï¼ˆisChar: trueï¼‰ ===== */
  "è•­ç†‡":{isChar:true,move:3,min:1,max:1,hp:125,atk:26,def:22, skills:[
    {id:"crash",name:"æ’é™£è¡è»",type:"attack",cd:3,range:"job",desc:"è‡ªæ20%æœ€å¤§HPï¼›0.8Ã—ä¸¦æ“Šé€€2ã€è³¦é²ç·©II",use:(a,d)=>{ const cost=Math.max(1,Math.round(a.hpMax*0.2)); a.hp=Math.max(1,a.hp-cost); log(`${a.id} è‡ªæ ${cost}`); hit(a,d,0.8); knockback(a,d,2); d.tags.slow2=1; render(); }},
    {id:"gale",name:"ç–¾ç‹¼æ é¢¨",type:"skillAOE",cd:4,range:1,desc:"ä»¥è‡ªèº«ç‚ºä¸­å¿ƒè±å½¢3 AOE 0.5Ã—ï¼›ç²è­·è¡›ï¼›é‹ªç‚ç„2å›åˆ",use:(a)=>{ const tiles=diamondTiles(a.x,a.y,3); const foes=enemiesOf(a.side).filter(u=>tiles.some(t=>t.x===u.x&&t.y===u.y)); foes.forEach(e=>hit(a,e,0.5)); tiles.forEach(t=>addTerrain(t.x,t.y,'fire',2)); a.tags.guard=1; log(`${a.id} å±•é–‹ç‚ç„èˆ‡è­·è¡›`); a.hasActed=true; alliesLeft.delete(a.id); selected=a; endActivation(); }},
    {id:"dragon",name:"é¾å˜¯ä¹å¤©",type:"skillAOE",cd:5,range:4,desc:"å°„ç¨‹4ã€è±å½¢2 AOEï¼›æ–½æ”¾å‰å°‡é˜²è½‰æ”»ï¼Œ0.6Ã—ï¼›å‘½ä¸­â‰¥3ç²ç‚é§+è­·è¡›",use:(a)=>{ targetAOESelect(a,4,2); }},
    {id:"defend",name:"èª“æ­»æè¡›",type:"self",cd:4,desc:"1å›åˆè­·è¡›ç¯„åœ+è‡³2æ ¼ï¼Œç²å¾©ä»‡ï¼ˆåæ“Š+30%ï¼‰",use:(u)=>{u.tags.guard=1;u.tags.guardRange2=1;u.tags.revenge=1;log(`${u.id} å®ˆè­·(2)+å¾©ä»‡`); return true;}},
    {id:"order",name:"è•­é–€å°‡ä»¤",type:"buffTarget",cd:3,range:2,desc:"å°2æ ¼å…§å‹è»ï¼šæ”»é˜²UPï¼ˆ1å›åˆï¼‰ï¼›è‹¥è‡ªèº«ç„¡å¾¡æ•µâ†’+1å±¤ï¼ˆå±•ç¤ºï¼‰",use:(a,t)=>{if(t.side!==a.side){log('åƒ…å°å‹è»');return false;} t.tags.buffAtk=1;t.tags.buffDef=1; if(!(a.tags.enemylayer>0)){ a.tags.enemylayer=(a.tags.enemylayer||0)+1; log(`${a.id} å¾¡æ•µå±¤+1ï¼ˆå±•ç¤ºï¼‰`);} render(); a.hasActed=true; alliesLeft.delete(a.id); selected=a; endActivation(); return true; }},
  ]},
  "é©šé£›ç¾½":{isChar:true,move:3,min:2,max:2,hp:95,atk:28,def:12, skills:[
    {id:"xiaoerwuxiang",name:"å°è€Œç„¡ç›¸",type:"self",cd:2,desc:"é¸æ“‡ 1 å€‹çµ•å­¸é‡‹æ”¾ï¼›ä½¿ç”¨å¾Œåˆ‡æ›ç‚ºã€Œæ€¨ç”Ÿå‰›å¾©ã€èˆ‡ã€Œå±±é­„ç´¢é­‚ã€ã€‚ã€ˆç¤ºç¯„ç”¨ï¼šåƒ…é¡¯ç¤ºèªªæ˜ã€‰",use:(u)=>{log("ã€å°è€Œç„¡ç›¸ã€‘ï¼ˆç¤ºç¯„ç”¨ï¼šåƒ…é¡¯ç¤ºèªªæ˜ï¼‰"); return true;}}
  ]},
  "èƒ§æ¢¦å©³å¦–":{isChar:true,move:3,min:2,max:2,hp:95,atk:18,def:12,
    skills:[
      {id:"mirrorHeal", name:"é¡æ˜ å›æ˜¥", type:"heal", cd:2, range:3, val:35,
       desc:"å°„ç¨‹3ï¼›å›å¾©35ï¼›éé‡æ²»ç™‚â†’è‡ªèº«ç²ã€Œé¡æœ¦æœ§ã€1å±¤ï¼›3æ ¼å…§å‹è»æ²»ç™‚+15%",
       use:(a,t)=>{
         let heal=35;
         if(manhattan(a,t)<=3) heal=Math.round(heal*1.15);
         const before=t.hp;
         t.hp=Math.min(t.hpMax, t.hp+heal);
         if(before+heal>t.hpMax){
           a.tags.mist=(a.tags.mist||0)+1;
           log(`${a.id} ç²å¾—é¡æœ¦æœ§ï¼ˆ${a.tags.mist}ï¼‰`);
         }
         render();
         return true;
       }},
      {id:"darkAegis", name:"æš—é§çµç•Œ", type:"self", cd:3,
       desc:"æ¶ˆè€—è‡³å¤š4å±¤é¡æœ¦æœ§ï¼šç‚º3æ ¼å…§å‹è»è³¦äºˆè­·ç›¾=ï¼ˆå±¤æ•¸Ã—10ï¼‰",
       use:(u)=>{
         const c=Math.min(4, u.tags.mist||0);
         if(c===0){ log("ç„¡é¡æœ¦æœ§å¯æ¶ˆè€—"); return false; }
         u.tags.mist-=c;
         for(const v of units){
           if(!v.dead && v.side===u.side && manhattan(u,v)<=3){
             v.tags.shield=(v.tags.shield||0)+c*10;
           }
         }
         log(`${u.id} æ¶ˆè€—${c}å±¤é¡æœ¦æœ§ï¼Œå±•é–‹æš—é§`);
         return true;
       }},
      {id:"mirrorSplit", name:"é¡åˆ†è™›å¯¦", type:"self", cd:6,
       desc:"éœ€é¡æœ¦æœ§â‰¥4ï¼šç›¸é„°ç©ºæ ¼å¬å–šåˆ†èº«ï¼ˆå­˜æ´»1å›åˆï¼‰ï¼Œå˜²è«·+é˜»æ“‹",
       use:(u)=>{
         if((u.tags.mist||0)<4){ log("é¡æœ¦æœ§æœªé”4å±¤"); return false; }
         const spot = neighbors(u.x,u.y).find(p=>inside(p.x,p.y) && !isBlocked(p.x,p.y) && !unitAt(p.x,p.y));
         if(!spot){ log("ç„¡ç›¸é„°ç©ºä½å¯å¬å–š"); return false; }
         u.tags.mist-=4;
         const clone={
           id:`${u.id}å½±`, side:u.side, job:"åˆ†èº«", attr:u.attr, soulId:null,
           x:spot.x, y:spot.y, hpMax:1, hp:1, atk:0, def:999, min:1, max:1, move:0,
           cd:{}, tags:{taunt:1, isClone:1, life:1}, bonusMove:0, dead:false,
           hasMoved:true, hasActed:true, loadout:[],
           turnStart:{x:spot.x,y:spot.y}, actionStart:{x:spot.x,y:spot.y}
         };
         units.push(clone);
         log(`${u.id} å¬å–šåˆ†èº«æ–¼ (${spot.x},${spot.y})`);
         render();
         return true;
       }},
    ]},
};

function diamondTiles(cx,cy,r){ const out=[]; for(let dx=-r;dx<=r;dx++){const rem=r-Math.abs(dx); for(let dy=-rem;dy<=rem;dy++){const x=cx+dx,y=cy+dy; if(inside(x,y)) out.push({x,y});}} return out; }
function targetAOESelect(a,rangeR,diamondR){
  log(`é¸å°„ç¨‹å…§ä¸­å¿ƒæ ¼ï¼ˆå°„ç¨‹${rangeR}ï¼Œè±å½¢${diamondR}ï¼‰`);
  phase="skillTarget"; skillLock={__special:"AOEcenter", range:rangeR, diamond:diamondR, caster:a};
  render();
  return null;
}

/* ====== é­‚çŸ³ï¼ˆä¸‰æšæ•ˆæœï¼‰ ====== */
const SOULSTONES={
  "èµ¤ç·´é¬¼":{label:"èµ¤ç·´é¬¼ï¼ˆ3ï¼‰",desc:"ä¸»å‹•æ”»æ“Šä¸”ç›®æ¨™â‰¥70%æ°£è¡€ï¼šå‚·å®³+20%",hooks:{
    computeAtk:(ctx)=>{ if(ctx.isActive && ctx.defender.hp/ctx.defender.hpMax>=0.70){ ctx.atkMul*=1.20; ctx.log?.push?.("èµ¤ç·´é¬¼+20%"); } }
  }},
  "å‰›ç ´é¬¼":{label:"å‰›ç ´é¬¼ï¼ˆ3ï¼‰",desc:"å‘¨åœ3æ ¼ç„¡å‹è»ï¼šæ”»+8%ï¼å—å‚·-8%",hooks:{
    computeAtk:(ctx)=>{ if(noAllyWithin(ctx.attacker,3)) ctx.atkMul*=1.08; }, computeDef:(ctx)=>{ if(noAllyWithin(ctx.defender,3)) ctx.defMul*=0.92; }
  }},
  "å¦„å¹»":{label:"å¦„å¹»ï¼ˆ3ï¼‰",desc:"æ–½æ”¾çµ•å­¸æˆ–è¢«æ”»å¾Œç–Šå±¤ï¼šæ¯å±¤å…¨å±¬+3%ï¼ˆâ‰¤5ï¼‰",hooks:{
    init:(u)=>{u.tags.mang=0;}, onSkillUse:(ctx)=>{ctx.user.tags.mang=Math.min(5,(ctx.user.tags.mang||0)+1);},
    onBeHit:(ctx)=>{ctx.defender.tags.mang=Math.min(5,(ctx.defender.tags.mang||0)+1);},
    computeAtk:(ctx)=>{const s=ctx.attacker.tags.mang||0; if(s) ctx.atkMul*=(1+0.03*s);},
    computeDef:(ctx)=>{const s=ctx.defender.tags.mang||0; if(s) ctx.defMul*=(1-0.03*s);}
  }},
  "é¬¼é¢èŠ±è››":{label:"é¬¼é¢èŠ±è››ï¼ˆ3ï¼‰",desc:"ä¸»æ”»å‰50%ï¼šè³¦ã€é²ç·©IIã€è•é­”ï¼ˆæ³•é˜²-30%ï¼‰ã€",hooks:{
    beforeAttack:(ctx)=>{ if(!ctx.isActive) return; if(Math.random()<0.5){ ctx.defender.tags.slow2=1; ctx.defender.tags.mdefDown30=1; ctx.log?.push?.("è››ï¼šé²ç·©II/è•é­”"); } }
  }},
  "ä¹ç’°æœ±è®":{label:"ä¹ç’°æœ±è®ï¼ˆ3ï¼‰",desc:"ä¸»å‹•é€ æˆå‚·å®³å¾Œï¼šçµ¦ã€ä¸­æ¯’(10%)ã€1å›åˆ",hooks:{
    afterAttack:(ctx)=>{ if(ctx.isActive && ctx.didDamage){ ctx.defender.tags.poison10=1; ctx.log?.push?.("æœ±è®ï¼šä¸­æ¯’"); } }
  }},
  "å¦–è¡“å¸«":{label:"å¦–è¡“å¸«ï¼ˆ3ï¼‰",desc:"ä½¿ç”¨å‚·å®³çµ•å­¸å¾Œ50%ä½¿è©²æŠ€CD-2",hooks:{
    onSkillUse:(ctx)=>{ try{ if(ctx && ctx.skill?.isDamage && Math.random()<0.5 && ctx.owner && ctx.owner.cd){ const sid = ctx.skill.id; ctx.owner.cd[sid] = Math.max(0, (ctx.owner.cd[sid]||0) - 2); ctx.log?.push?.("å¦–è¡“å¸«ï¼šCD-2"); } }catch(e){ console.warn("å¦–è¡“å¸« hook error:", e);} }
  }},
  "è’è«":{label:"è’è«ï¼ˆ3ï¼‰",desc:"æ™®é€šæ”»æ“Šå‚·å®³+20%",hooks:{ computeAtk:(ctx)=>{ if(!ctx.isSkill) ctx.atkMul*=1.20; } }},
  "ç¾½é­…":{label:"ç¾½é­…ï¼ˆ3ï¼‰",desc:"2æ ¼å…§ç„¡å‹è»ï¼šå‚·+12%ï¼å—å‚·-12%",hooks:{
    computeAtk:(ctx)=>{ if(noAllyWithin(ctx.attacker,2)) ctx.atkMul*=1.12; }, computeDef:(ctx)=>{ if(noAllyWithin(ctx.defender,2)) ctx.defMul*=0.88; }
  }},
  "é ­ç‹¼":{label:"é ­ç‹¼ï¼ˆ3ï¼‰",desc:"å‚·+5%ï¼›ä¸»å‹•å‚·å¾Œï¼šç²ã€è¿…æ·IIï¼ˆç§»+2ï¼‰ã€",hooks:{
    computeAtk:(ctx)=>{ ctx.atkMul*=1.05; }, afterAttack:(ctx)=>{ if(ctx.isActive&&ctx.didDamage){ ctx.attacker.tags.haste2=1; } }
  }},
  "ç¾…é¬¼":{label:"ç¾…é¬¼ï¼ˆ3ï¼‰",desc:"å‚·+10%ï¼›ä¸»æ”»æ™‚å—å‚·-10%",hooks:{
    computeAtk:(ctx)=>{ ctx.atkMul*=1.10; }, computeDef:(ctx)=>{ if(ctx.isActive) ctx.defMul*=0.90; }
  }},
  "å’’çŸ³å…µ":{label:"å’’çŸ³å…µï¼ˆ3ï¼‰",desc:"å—å‚·-10%",hooks:{ computeDef:(ctx)=>{ ctx.defMul*=0.90; } }},
  "å†°é­”è ":{label:"å†°é­”è ï¼ˆ3ï¼‰",desc:"è¢«æ”»æ™‚é›™é˜²+15%",hooks:{ computeDef:(ctx)=>{ if(!ctx.isActive) ctx.defMul*=0.85; } }},
};
const SOUL_IDS=Object.keys(SOULSTONES);
function noAllyWithin(u,r){ for(const v of units){ if(v.dead||v.side!==u.side||v===u) continue; if(manhattan(u,v)<=r) return false; } return true; }

/* ===================== ä½ˆé™£é è¨­ï¼ˆåˆ†é›¢ä¾†æºï¼‰ ===================== */
let setupData={
  A1:{kind:"è§’è‰²", item:"è•­ç†‡", attr:"ç«", soul:"ç¾…é¬¼", skills:["crash","gale","defend"]},
  A2:{kind:"è·æ¥­", item:"ä¿ å®¢", attr:"å…‰", soul:"é ­ç‹¼", skills:["combo","light","bleed"]},
  A3:{kind:"è§’è‰²", item:"èƒ§æ¢¦å©³å¦–", attr:"æš—", soul:"å’’çŸ³å…µ", skills:["mirrorHeal","darkAegis","mirrorSplit"]},
  E1:{kind:"è·æ¥­", item:"éµè¡›", attr:"æš—", soul:"å‰›ç ´é¬¼", skills:["guard","taunt","block"]},
  E2:{kind:"è·æ¥­", item:"ç¾½å£«", attr:"å†°", soul:"é¬¼é¢èŠ±è››", skills:["pierce","aim","repel"]},
  E3:{kind:"è·æ¥­", item:"å’’å¸«", attr:"å¹½", soul:"èµ¤ç·´é¬¼", skills:["bolt","slow","veil"]},
};

function mkUnit(slot){
  const conf=setupData[slot.id];
  const jd=JOBS[conf.item]; // item å·²åˆ†è·æ¥­/è§’è‰²
  const u={ id:slot.id, side:slot.side, job:conf.item, attr:conf.attr, soulId:conf.soul,
    x:slot.x, y:slot.y, hpMax:jd.hp, hp:jd.hp, atk:jd.atk, def:jd.def, min:jd.min, max:jd.max, move:jd.move,
    cd:{}, tags:{}, bonusMove:0, dead:false, hasMoved:false, hasActed:false,
    loadout: (conf.skills||[]).slice(0,3),
    turnStart:{x:slot.x,y:slot.y}, actionStart:{x:slot.x,y:slot.y}
  };
  u.soul=SOULSTONES[u.soulId]||null; if(u.soul?.hooks?.init) u.soul.hooks.init(u);
  return u;
}
function alliesOf(side){return units.filter(u=>!u.dead && u.side===side)}
function enemiesOf(side){return units.filter(u=>!u.dead && u.side!==side)}
function unitAt(x,y){return units.find(u=>!u.dead && u.x===x && u.y===y)}

/* ===================== å›åˆç®¡ç†ï¼ˆä½ ä»»é¸ â†” æ•µæ–¹ä¸€éš»ï¼‰ ===================== */
function battleStart(){
  round=1; roundEl.textContent=round;
  for(const u of units){ u.hasActed=false; u.hasMoved=false; u.tags.aim=0; u.tags.aimCharges=0; }
  log("æˆ°é¬¥é–‹å§‹");
  turnStart();
}

function turnStart(){
  log(`ç¬¬ ${round} å›åˆé–‹å§‹`);
  alliesLeft.clear(); enemiesLeft.clear();
  for(const u of units){
    if(u.dead) continue;
    u.hasActed=false; u.hasMoved=false;
    u.turnStart={x:u.x,y:u.y}; u.actionStart={x:u.x,y:u.y};
    (u.side==='ally'?alliesLeft:enemiesLeft).add(u.id);
    if(u.soul?.hooks?.turnStart) u.soul.hooks.turnStart(u);
  }
  decayTerrains();
  beginPlayerPhase();
}

function beginPlayerPhase(){
  selected=null; phase="idle"; turnEl.textContent=`ç©å®¶ï¼ˆå‰©ï¼š${alliesLeft.size}ï¼‰`; render();
}

function enemyTakesOne(){
  const enemy = units.find(u=>!u.dead && u.side==='enemy' && enemiesLeft.has(u.id));
  if(!enemy){
    if(alliesLeft.size>0){ beginPlayerPhase(); return; }
    turnEnd(); return;
  }
  aiActFor(enemy);
}

function turnEnd(){
  // å›åˆæœ« DOT / åœ°å½¢
  for(const u of units.filter(u=>!u.dead)){
    if(terrainAt(u.x,u.y,'fire')){
      const loss=10; u.hp=Math.max(0,u.hp-loss);
      log(`${u.id} å—ç‚ç„ç¼ç‡’ -${loss}`);
      if(u.hp===0){u.dead=true; log(`${u.id} é™£äº¡ï¼`);}
    }
  }
  // åˆ†èº«å£½å‘½çµæŸ
  for(const u of units){
    if(u.tags?.isClone){
      u.tags.life = (u.tags.life||0) - 1;
      if(u.tags.life<=0 && !u.dead){
        u.dead = true; log(`${u.id} åˆ†èº«æ¶ˆæ•£`);
      }
    }
  }
  // å…¨å“¡ CD-1
  for(const u of units){ for(const k in u.cd) u.cd[k]=Math.max(0,u.cd[k]-1); }

  if(checkGameOver()) return;
  round+=1; roundEl.textContent=round;
  turnStart();
}

/* ===================== ç¹ªè£½ ===================== */
function render(){
  board.innerHTML=""; drawBlocks(); drawTerrains();
  if(selected && phase!=="idle"){
    if(phase==="move"){ const MR=Math.max(0,selected.move+(selected.bonusMove||0)-(selected.tags.slow?1:0)); for(const t of reach(selected,MR)) paint(t.x,t.y,"move"); }
    if(phase==="act"){ paintAttackable(selected); }
    if(phase==="skillTarget" && skillLock && !skillLock.__special){ paintTargetsForSkill(selected, skillLock); }
    if(phase==="skillTarget" && skillLock?.__special==="AOEcenter"){ paintAOECenters(selected, skillLock.range, skillLock.diamond); }
  }
  for(const u of units){
    const el=document.createElement("div");
    el.className=`unit ${u.side} ${u.dead?'dead':''} ${selected&&selected.id===u.id?'sel':''}`;
    el.style.left=`${u.x*CELL}px`; el.style.top=`${u.y*CELL}px`;
    const soul = SOULSTONES[u.soulId]; const soulName = soul?.label||'ç„¡'; const soulDesc=soul?.desc||'';
    el.innerHTML=`<div>${u.id}${u.hasActed?'âœ“':''}</div>
      <div class="badge" title="${soulName}ï¼š${soulDesc}" style="color:${colorAttr(u.attr)};border-color:${colorAttr(u.attr)}">${u.job}/${u.attr}ï½œ${soulName}</div>
      <div class="hpbar"><div class="hp" style="width:${(u.hp/u.hpMax*100).toFixed(0)}%"></div></div>`;
    el.onclick=()=>onUnitClick(u);
    board.appendChild(el);
  }
  drawActionBar();
  renderActionBar();
  renderInfo();
  trimLog();
}
function paint(x,y,cls){const d=document.createElement("div");d.className=`tile ${cls}`;d.style.left=`${x*CELL}px`;d.style.top=`${y*CELL}px`;board.appendChild(d);}
function paintAttackable(u){
  for(const e of enemiesOf(u.side)){ const d=manhattan(u,e); const min=(u.job==="ç¾½å£«")?2:u.min, max=(u.job==="ç¾½å£«")?2:u.max;
    if(d>=min&&d<=max){ if(d>1 && !canIgnoreLoS(u)){ if(!lineOfSight(u.x,u.y,e.x,e.y)) continue; } paint(e.x,e.y,"atk"); } } }
function paintTargetsForSkill(u,sk){
  const rng=sk.range==="job"?u.max:sk.range, min=sk.type==="attack"?((u.job==="ç¾½å£«")?2:u.min):1;
  for(const t of units){ if(t.dead)continue; if(sk.type==="attack"&&t.side===u.side)continue; if(sk.type==="heal"&&t.side!==u.side)continue;
    const d=manhattan(u,t); if(d>=min&&d<=rng){ if(sk.type==="attack"&&d>1&&!canIgnoreLoS(u)){ if(!lineOfSight(u.x,u.y,t.x,t.y)) continue; } paint(t.x,t.y, sk.type==="attack"?"atk":"move"); }}
}
function paintAOECenters(u,rangeR,diamondR){
  for(let y=0;y<GRID_H;y++)for(let x=0;x<GRID_W;x++){const d=Math.abs(u.x-x)+Math.abs(u.y-y); if(d<=rangeR){ if(d<=1 || canIgnoreLoS(u) || lineOfSight(u.x,u.y,x,y)) paint(x,y,"move"); }}
}

/* ===================== è·¯å¾‘ ===================== */
function reach(u,R){
  const vis=new Set([`${u.x},${u.y}`]); const Q=[{x:u.x,y:u.y,d:0}], out=[];
  while(Q.length){ const {x,y,d}=Q.shift(); if(d===R) continue;
    for(const {x:nx,y:ny} of neighbors(x,y)){ const key=`${nx},${ny}`; if(vis.has(key)) continue; if(isBlocked(nx,ny)||unitAt(nx,ny)) continue;
      vis.add(key); Q.push({x:nx,y:ny,d:d+1}); if(!(nx===u.x&&ny===u.y)) out.push({x:nx,y:ny}); } }
  return out;
}

/* ===================== äº’å‹•ï¼ˆä»»é¸å°šæœªè¡Œå‹•çš„æˆ‘æ–¹ï¼‰ ===================== */
function onUnitClick(u){
  if(u.dead || EDIT_MODE) return;

  // è‹¥åˆ‡æ›åˆ°å¦ä¸€åã€Œæˆ‘æ–¹ã€â†’ å…ˆé‚„åŸå‰ä¸€ä½æœªçµæŸè¡Œå‹•è€…
  if(selected && selected.side==="ally" && u.side==="ally" && selected.id!==u.id){
    rollbackToActionStart(selected);
  }

  // é»æ•µäººç•¶ä½œæ”»æ“Šç›®æ¨™ï¼ˆéœ€å·²é¸ä¸­ä¸€åæˆ‘æ–¹ï¼‰
  if(selected && phase==="act" && u.side!=="ally"){ tryAttack(selected,u); return; }

  // æŠ€èƒ½é¸å–ç›®æ¨™
  if(selected && phase==="skillTarget" && skillLock && !skillLock.__special){
    if(RULE_MOVE_OR_ACT && selected.hasMoved && !["self","dash","buff"].includes(skillLock.type)){ log("åš´æ ¼è¦å‰‡ï¼šå·²ç§»å‹•ï¼Œæœ¬æ¬¡è¡Œå‹•ä¸å¯å†è¡Œå‹•ã€‚"); return; }
    const d=manhattan(selected,u); const rng=skillLock.range==="job"?selected.max:skillLock.range; const min=(skillLock.type==="attack")?((selected.job==="ç¾½å£«")?2:selected.min):1;
    if(d<min || d>rng) return;
    if(skillLock.type==="attack" && d>1 && !canIgnoreLoS(selected)){ if(!lineOfSight(selected.x,selected.y,u.x,u.y)){ log("è¦–ç·šè¢«é˜»æ“‹ã€‚"); return; } }
    useSkill(selected,u,skillLock); return;
  }

  // é¸ä¸­ä»»ä¸€ã€Œæˆ‘æ–¹æœªè¡Œå‹•ã€å–®ä½
  if(u.side!=="ally"){ return; }
  if(u.hasActed){ log("æ­¤å–®ä½æœ¬å›åˆå·²è¡Œå‹•ã€‚"); return; }
  selected=u; setActionStart(selected); phase="move"; render();
}

board.addEventListener("click",(ev)=>{
  const rect=board.getBoundingClientRect(); const x=Math.floor((ev.clientX-rect.left)/CELL), y=Math.floor((ev.clientY-rect.top)/CELL);
  if(!inside(x,y)) return;
  if(EDIT_MODE){ if(!unitAt(x,y)) toggleBlock(x,y); return; }

  if(!selected || selected.side!=="ally") return;

  // è•­ç†‡ã€Œé¾å˜¯ä¹å¤©ã€é¸ä¸­å¿ƒ
  if(phase==="skillTarget" && skillLock?.__special==="AOEcenter"){
    const a=skillLock.caster; if(a.id!==selected.id) return; const d=manhattan(a,{x,y});
    if(d<=skillLock.range){ if(d<=1 || canIgnoreLoS(a) || lineOfSight(a.x,a.y,x,y)){
      const tiles=diamondTiles(x,y,skillLock.diamond);
      const foes=enemiesOf(a.side).filter(u=>tiles.some(t=>t.x===u.x&&t.y===u.y)&& checkLoS(a,u));
      a.tags.tmpAtkBoost=(a.tags.tmpAtkBoost||0)+a.def; foes.forEach(e=>hit(a,e,0.6)); a.tags.tmpAtkBoost=0;
      if(foes.length>=3){ a.tags.fireArmor=1; a.tags.guard=1; log(`${a.id} å‘½ä¸­${foes.length}ï¼šç‚é§+è­·è¡›`); }
      render(); selected.hasActed=true; alliesLeft.delete(selected.id); endActivation(); return;
    }}
  }

  if(unitAt(x,y)) return;
  if(phase!=="move" || selected.hasMoved) return;
  const MR=Math.max(0,selected.move+(selected.bonusMove||0)-(selected.tags.slow?1:0));
  const tiles=reach(selected,MR);
  if(tiles.find(t=>t.x===x&&t.y===y)){
    const dist=Math.abs(selected.x-x)+Math.abs(selected.y-y);
    selected.x=x; selected.y=y; selected.hasMoved=true; selected.bonusMove=0;
    if(dist>=2) selected.tags.moved2=1;
    log(`${selected.id} ç§»å‹•åˆ° (${x},${y})`);
    phase=RULE_MOVE_OR_ACT?"move":"act"; render();
  }
});

/* ===================== å‹•ä½œåˆ— ===================== */
function drawActionBar(){
  actions.innerHTML="";
  if(!selected || selected.side!=="ally") return;

  const atkBtn=btn(`âš”ï¸ æ™®é€šæ”»æ“Š${RULE_MOVE_OR_ACT&&selected.hasMoved?'ï¼ˆç¦ç”¨ï¼šå·²ç§»å‹•ï¼‰':''}`, ()=>{
    if(RULE_MOVE_OR_ACT && selected.hasMoved){ log("åš´æ ¼è¦å‰‡ï¼šå·²ç§»å‹•ï¼Œæœ¬æ¬¡è¡Œå‹•ä¸å¯å†è¡Œå‹•ã€‚"); return; }
    phase="act"; skillLock=null; render();
  });
  if(RULE_MOVE_OR_ACT && selected.hasMoved) atkBtn.disabled=true; actions.appendChild(atkBtn);

  const jd=JOBS[selected.job]; selected.loadout.forEach(skId=>{
    const sk=jd.skills.find(s=>s.id===skId); if(!sk) return; const left=(selected.cd && selected.cd[sk.id]) || 0;
    const b=btn(`${sk.name}`, ()=>{
      if(left) return;
      if(RULE_MOVE_OR_ACT && selected.hasMoved && !["self","dash","buff","skillAOE","buffTarget"].includes(sk.type)){ log("åš´æ ¼è¦å‰‡ï¼šå·²ç§»å‹•ï¼Œæœ¬æ¬¡è¡Œå‹•ä¸å¯å†è¡Œå‹•ã€‚"); return; }
      if(sk.needPhase && sk.needPhase!==phase){ log(`ã€Œ${sk.name}ã€éœ€åœ¨${sk.needPhase==='move'?'ç§»å‹•éšæ®µ':'ç•¶å‰éšæ®µ'}ä½¿ç”¨ã€‚`); return; }
      skillLock=sk;
      if(["self","dash","buff"].includes(sk.type)){ useSkill(selected,selected,sk); render(); }
      else if(sk.type==="skillAOE"){ if(RULE_MOVE_OR_ACT && selected.hasMoved){ log("åš´æ ¼è¦å‰‡ï¼šå·²ç§»å‹•ï¼Œæœ¬æ¬¡è¡Œå‹•ä¸å¯å†è¡Œå‹•ã€‚"); return; } if(sk.id==="gale"){ sk.use(selected); selected.cd[sk.id]=sk.cd; } else if(sk.id==="dragon"){ sk.use(selected); selected.cd[sk.id]=sk.cd; } }
      else if(sk.type==="buffTarget"){ phase="skillTarget"; render(); }
      else { phase="skillTarget"; render(); }
    });
    b.title = `${sk.desc}${left?`ï¼ˆå†·å»å‰© ${left}ï¼‰`:''}`;
    if(left) b.disabled=true;
    if(sk.needPhase==="move" && selected.hasMoved) b.disabled=true;
    actions.appendChild(b);
  });

  actions.appendChild(btn("â†©ï¸ æ’¤éŠ·åˆ°æœ¬æ¬¡è¡Œå‹•é–‹å§‹", ()=>{
    if(selected){ rollbackToActionStart(selected); }
    render();
  }));

  actions.appendChild(btn("â­ï¸ çµæŸæœ¬æ¬¡è¡Œå‹•", ()=>{ if(selected) endActivation(); }));
}
function btn(txt,fn){const b=document.createElement("button");b.className="btn";b.textContent=txt;b.onclick=fn;return b;}

/* ===================== æˆ°é¬¥/æŠ€èƒ½/é­‚çŸ³ ===================== */
function canIgnoreLoS(u){ if(u.tags.aim && u.tags.aimCharges>0) return true; return false; }
function consumeIgnoreLoS(u){ if(u.tags.aim && u.tags.aimCharges>0){ u.tags.aimCharges--; return; } }
function checkLoS(a,d){ const dist=manhattan(a,d); if(dist<=1) return true; if(canIgnoreLoS(a)){ consumeIgnoreLoS(a); return true; } return lineOfSight(a.x,a.y,d.x,d.y); }

function tryAttack(a,d){
  const d0=manhattan(a,d), min=(a.job==="ç¾½å£«")?2:a.min, max=(a.job==="ç¾½å£«")?2:a.max;
  if(d0<min||d0>max){ log("ä¸åœ¨æ”»æ“Šè·é›¢ã€‚"); return; }
  if(!checkLoS(a,d)){ log("è¦–ç·šè¢«é˜»æ“‹ã€‚"); return; }
  attack(a,d);
}

function computeDamage(attacker,defender,ratio=1,isSkill=false,skillObj=null){
  const logBuff=[];
  const ctx={ attacker, defender, isActive:true, isSkill, skill:skillObj, atkMul:1, defMul:1, log:logBuff, owner:attacker };
  attacker.soul?.hooks?.computeAtk?.(ctx);
  defender.soul?.hooks?.computeDef?.(ctx);

  const tmpAtk=attacker.tags?.tmpAtkBoost||0;
  const bers = attacker.tags?.berserk?.charges>0 ? attacker.tags.berserk : null;
  const pierce = (bers?bers.pierce:0);

  const defStat=Math.max(0, defender.def * (1 - pierce) * (defender.tags.defdown?0.7:1));
  let atkStat=Math.round((attacker.atk+tmpAtk) * (attacker.tags.focus?1.2:1) * ctx.atkMul);
  let base=Math.max(5, Math.round(atkStat - defStat/2));
  const mul=elemMul(attacker.attr, defender.attr);
  let guardMul = defender.tags.guard ? 0.5 : 1.0;
  const bersAdd = bers ? (1 + bers.bonus) : 1;
  let dmg=Math.max(1, Math.round(base * mul * ratio * guardMul * bersAdd * ctx.defMul));

  if(defender.tags.shield){ const s=defender.tags.shield; const take=Math.min(s,dmg); defender.tags.shield-=take; dmg-=take; if(take>0) log(`${defender.id} è­·ç›¾å¸æ”¶ ${take}`); }
  return {dmg, logBuff, pierce, mul};
}
function baseHit(a,d,ratio=1,isSkill=false,skillObj=null){
  a.soul?.hooks?.beforeAttack?.({attacker:a,defender:d,isActive:true,isSkill,skill:skillObj, log:[]});
  const {dmg,logBuff,pierce,mul}=computeDamage(a,d,ratio,isSkill,skillObj);
  const hpB=d.hp; d.hp=Math.max(0,d.hp-dmg); const didDamage=d.hp<hpB;

  log(`${a.id}[${a.job}/${a.attr}] â†’ ${d.id}[${d.job}/${d.attr}] å‚·å®³ ${dmg}ï¼ˆå±¬æ€§Ã—${mul.toFixed(2)}${pierce?`;ç ´ç”²${(pierce*100)|0}%`:''}ï¼‰`);
  if(logBuff.length) log("é­‚çŸ³ï¼š"+logBuff.join("ï¼Œ"));
  if(d.hp===0){ d.dead=true; log(`${d.id} é™£äº¡ï¼`); }

  a.soul?.hooks?.afterAttack?.({attacker:a,defender:d,didDamage,isActive:true,isSkill,skill:skillObj, log:[]});
  d.soul?.hooks?.onBeHit?.({attacker:a,defender:d,didDamage,isActive:true,isSkill,skill:skillObj, log:[]});
  render();
}
function hit(a,d,ratio=1){ baseHit(a,d,ratio,false,null); }
function attack(a,d){ baseHit(a,d,1.0,false,null); selected.hasActed=true; alliesLeft.delete(selected.id); endActivation(); }

function useSkill(a, target, sk){
  // å…ˆé€šçŸ¥é­‚çŸ³ï¼šä½¿ç”¨æŠ€èƒ½
  a.soul?.hooks?.onSkillUse?.({
    user:a,
    skill:{id:sk.id, isDamage: sk.type==="attack" || sk.type==="skillAOE"},
    owner:a,
    log:[]
  });

  let success = true;

  if (sk.type==="self" || sk.type==="dash" || sk.type==="buff"){
    const ret = sk.use(a);
    success = (ret!==false);
    if (success){
      a.cd[sk.id]=sk.cd;
      selected.hasActed=true; alliesLeft.delete(selected.id);
      endActivation();
    } else {
      log(`ã€Œ${sk.name}ã€æ¢ä»¶ä¸è¶³ï¼Œæœªæ¶ˆè€—è¡Œå‹•ã€‚`);
    }
    return;
  }

  if (sk.type==="buffTarget"){
    const ret = sk.use(a, target);
    success = (ret!==false);
    if (success){
      a.cd[sk.id]=sk.cd;
      if (!a.hasActed){ // æœ‰äº›æŠ€èƒ½å…§å·²çµæŸ
        selected.hasActed=true; alliesLeft.delete(selected.id);
        endActivation();
      }
    } else {
      log(`ã€Œ${sk.name}ã€æ¢ä»¶ä¸è¶³ï¼Œæœªæ¶ˆè€—è¡Œå‹•ã€‚`);
    }
    return;
  }

  if (sk.type==="attack"){
    baseHit(a, target, 1.0, true, sk);
    a.cd[sk.id]=sk.cd;
    selected.hasActed=true; alliesLeft.delete(selected.id);
    endActivation();
    return;
  }

  if (sk.type==="heal"){
    const ret = sk.use(a, target);
    success = (ret!==false);
    if (success){
      a.cd[sk.id]=sk.cd;
      selected.hasActed=true; alliesLeft.delete(selected.id);
      endActivation();
    } else {
      log(`ã€Œ${sk.name}ã€æ¢ä»¶ä¸è¶³ï¼Œæœªæ¶ˆè€—è¡Œå‹•ã€‚`);
    }
    return;
  }

  if (sk.type==="skillAOE"){
    a.cd[sk.id]=sk.cd; // gale/dragon å…§è™•ç†è¡Œå‹•çµæŸ
    return;
  }
}

/* æ“Šé€€ */
function knockback(att,a,dist){
  let dx=Math.sign(a.x-att.x), dy=Math.sign(a.y-att.y);
  if(Math.abs(dx)+Math.abs(dy)===2){ if(Math.abs(a.x-att.x) > Math.abs(a.y-att.y)) dy=0; else dx=0; }
  let nx=a.x, ny=a.y;
  for(let k=0;k<dist;k++){ const tx=nx+dx, ty=ny+dy; if(!inside(tx,ty) || isBlocked(tx,ty) || unitAt(tx,ty)) break; nx=tx; ny=ty; }
  if(nx!==a.x || ny!==a.y){ a.x=nx; a.y=ny; log(`${a.id} è¢«æ“Šé€€åˆ° (${nx},${ny})`); }
}

/* ===================== è¡Œå‹•çµæŸ â†’ äº¤æ›¿æ•µæ–¹ ===================== */
function endActivation(){
  const u = selected;

  // ç©å®¶ä¸»å‹•çµæŸ â†’ è¦–ç‚ºè·³éä¹Ÿæ¶ˆè€—è¡Œå‹•
  if (u && u.side==="ally" && !u.hasActed){
    u.hasActed = true;
    alliesLeft.delete(u.id);
  }

  if(u){
    u.actionStart={x:u.x,y:u.y}; // æ¸…æ’¤éŠ·é»
    for(const k in u.cd){ u.cd[k]=Math.max(0,u.cd[k]-1); } // è‡ªå·±æŠ€èƒ½ -1
  }

  selected=null; phase="idle"; render();
  if(checkGameOver()) return;

  if(enemiesLeft.size>0){ enemyTakesOne(); }
  else if(alliesLeft.size>0){ beginPlayerPhase(); }
  else { turnEnd(); }
}

/* ===================== AIï¼ˆä¸€æ¬¡åªæ“ä½œä¸€åï¼‰ ===================== */
function aiActFor(actor){
  if(actor.dead || !enemiesLeft.has(actor.id)){ enemyDone(); return; }

  const allFoesRaw = alliesOf("ally");
  const foes = allFoesRaw.some(f=>f.tags?.taunt) ? allFoesRaw.filter(f=>f.tags?.taunt) : allFoesRaw;

  const tgtStay=foes.filter(e=>inRange(actor,e) && checkLoS(actor,e))
                    .sort((a,b)=>elemMul(actor.attr,b.attr)-elemMul(actor.attr,a.attr))[0];
  if(tgtStay){
    baseHit(actor,tgtStay,1.0,false,null);
    actor.hasActed=true; enemiesLeft.delete(actor.id);
    enemyDone(); 
    return;
  }

  const foe=nearest(actor,foes); const step=bestStep(actor,foe,actor.move);
  if(step){ actor.x=step.x; actor.y=step.y; actor.hasMoved=true; log(`${actor.id} å‰é€²åˆ° (${actor.x},${actor.y})`); render(); }
  actor.hasActed=true; enemiesLeft.delete(actor.id);
  enemyDone();
}
function enemyDone(){
  if(alliesLeft.size>0){ beginPlayerPhase(); }
  else if(enemiesLeft.size>0){ enemyTakesOne(); }
  else { turnEnd(); }
}
function inRange(a,b){const d=manhattan(a,b); if(a.job==="ç¾½å£«") return d===2; return (d>=a.min && d<=a.max);}
function nearest(from,list){let best=null,bd=1e9; for(const t of list){const d=manhattan(from,t); if(d<bd){bd=d;best=t;}} return best;}
function bestStep(u,target,R){
  const tiles=reach(u,R); tiles.push({x:u.x,y:u.y});
  const goal=u.min===1?1:2;
  tiles.sort((a,b)=>{
    const da=Math.abs(a.x-target.x)+Math.abs(a.y-target.y);
    const db=Math.abs(b.x-target.x)+Math.abs(b.y-target.y);
    return Math.abs(da-goal)-Math.abs(db-goal);
  });
  return tiles[0]||null;
}

/* ===================== è¡Œå‹•æ¢ & æˆ°å ± ===================== */
function renderActionBar(){
  const A=document.getElementById('barAllies'), E=document.getElementById('barEnemies');
  if(!A||!E) return;
  A.innerHTML=''; E.innerHTML='';
  const allies=units.filter(u=>!u.dead&&u.side==='ally'); const enemies=units.filter(u=>!u.dead&&u.side!=='ally');
  function chip(u){
    const d=document.createElement('div');
    d.className='dot'+(u.side==='enemy'?' foe':'')+(u.hasActed?' done':'');
    d.textContent = `${u.id}${u.hasActed?'âœ“':''}`;
    const soul=SOULSTONES[u.soulId];
    d.title = `${u.job}/${u.attr}ï½œé­‚çŸ³ï¼š${soul?.label||'ç„¡'} â€” ${soul?.desc||''}`;
    return d;
  }
  allies.forEach(u=>A.appendChild(chip(u)));
  enemies.forEach(u=>E.appendChild(chip(u)));
}
// æˆ°å ±å¯æ”¶åˆ + ä¸Šé™
let logCollapsed=false;
document.getElementById('toggleLog').onclick=()=>{
  logCollapsed=!logCollapsed;
  document.getElementById('log').style.display = logCollapsed?'none':'block';
  document.getElementById('toggleLog').textContent = logCollapsed?'å±•é–‹ç´€éŒ„':'æ”¶åˆç´€éŒ„';
};
function trimLog(){ const maxLines=200; while(logEl.children.length>maxLines){ logEl.removeChild(logEl.firstChild); } }

/* ===================== å³å´è³‡è¨Š ===================== */
function renderInfo(){
  const box = document.getElementById('info');
  if(!box){ return; }

  if(!selected){
    box.innerHTML = `
      <div class="info-card">
        <div class="info-head"><span class="name">æœªé¸å–å–®ä½</span><span class="stat">â€”</span></div>
        <div class="info-body small" style="opacity:.7">é»é¸æ£‹ç›¤ä¸Šçš„å‹è»æŸ¥çœ‹æŠ€èƒ½èˆ‡é­‚çŸ³è³‡è¨Šã€‚</div>
      </div>`;
    return;
  }

  const u = selected;
  const jobDef = JOBS[u.job];
  if(!jobDef){ box.innerHTML=''; return; }

  const skillsHtml = u.loadout.map(id=>{
    const sk = jobDef.skills.find(s=>s.id===id);
    if(!sk) return '';
    const left = (u.cd && u.cd[sk.id]) || 0;
    const cdTag = left ? `å†·å» ${left}/${sk.cd}` : `å†·å» ${sk.cd}`;
    return `<div class="skill">
      <b>ğŸ§© ${sk.name}</b><div class="meta">${cdTag}</div>
      <hr class="sep"><div class="small">${sk.desc}</div>
    </div>`;
  }).join('');

  const soul = SOULSTONES[u.soulId];
  const soulHtml = `<div class="soul"><b>ğŸ’  é­‚çŸ³èƒ½åŠ›</b><hr class="sep"><div>${soul ? `${soul.label} â€” ${soul.desc}` : 'ç„¡'}</div></div>`;

  box.innerHTML = `
    <div class="info-card">
      <div class="info-head">
        <span class="name">${u.id}ã€€${u.job} <span class="tag" style="margin-left:6px;border-color:${colorAttr(u.attr)};color:${colorAttr(u.attr)}">${u.attr}</span></span>
        <span class="stat">â¤ ${u.hp}/${u.hpMax}</span>
      </div>
      <div class="info-body">
        ${skillsHtml || '<div class="small">ï¼ˆç„¡æŠ€èƒ½ï¼‰</div>'}
        ${soulHtml}
      </div>
    </div>
  `;
}

/* ===================== å‹è²  / æ—¥èªŒ ===================== */
function checkGameOver(){
  const A=alliesOf("ally").length>0, B=alliesOf("enemy").length>0;
  if(!A||!B){ log(!B?"ä½ è´äº†ğŸ‰":"ä½ è¢«æ“Šæ•—äº†"); return true; }
  return false;
}
function log(msg){const t=new Date().toLocaleTimeString('zh-TW',{hour12:false}); const d=document.createElement("div"); d.textContent=`[${t}] ${msg}`; logEl.appendChild(d); logEl.scrollTop=logEl.scrollHeight;}

/* ===================== è¨­å®šé¢æ¿ï¼ˆä¾†æºåˆ†é›¢ï¼‰ ===================== */
const setup=document.getElementById("setup"), setupRowsEl=document.getElementById("setupRows");
document.getElementById("openSetup").onclick=()=>openSetup();
document.getElementById("closeSetup").onclick=()=>setup.style.display="none";
document.getElementById("applyTeam").onclick=()=>{applySetup(); setup.style.display="none"; newGame();};
document.getElementById("randTeam").onclick=()=>randomizeSetup();
document.getElementById("clearBlocks").onclick=()=>{ initBlocks(); terrains=[]; render(); };
document.getElementById("randomBlocks").onclick=()=>{ for(let y=0;y<GRID_H;y++) for(let x=0;x<GRID_W;x++) if(Math.random()<0.07&&!unitAt(x,y)) blocks[y][x]=true; render(); };

function openSetup(){
  setupRowsEl.innerHTML=""; document.getElementById('mapW').value=GRID_W; document.getElementById('mapH').value=GRID_H;

  const jobList = Object.keys(JOBS).filter(k=>!JOBS[k].isChar);
  const charList = Object.keys(JOBS).filter(k=>JOBS[k].isChar);

  for(const s of slots){
    const tr=document.createElement("tr");

    // ä¾†æºï¼ˆè·æ¥­ / è§’è‰²ï¼‰
    const selKind=mkSelect(["è·æ¥­","è§’è‰²"], setupData[s.id].kind);
    const selItem=document.createElement("select");
    function refillItem(){
      selItem.innerHTML="";
      const list = selKind.value==="è·æ¥­" ? jobList : charList;
      list.forEach(x=>{const o=document.createElement('option');o.value=x;o.textContent=x;selItem.appendChild(o)});
      const want = setupData[s.id].item;
      selItem.value = list.includes(want) ? want : list[0];
    }
    refillItem();
    selKind.onchange=()=>{ refillItem(); refreshSkillBox(); };

    // å±¬æ€§ã€é­‚çŸ³
    const selAttr=mkSelect(ATTR, setupData[s.id].attr);
    const selSoul=mkSelect(Object.keys(SOULSTONES), setupData[s.id].soul, k=>SOULSTONES[k].label);

    // æŠ€èƒ½ï¼ˆè·Ÿè‘— item è®ŠåŒ–ï¼‰
    const skillsBox=document.createElement('div'); skillsBox.className="skills";
    function refreshSkillBox(){
      skillsBox.innerHTML="";
      const js=JOBS[selItem.value].skills;
      function makeSkillSelect(defId){ const sel=document.createElement('select'); js.forEach(sk=>{const o=document.createElement('option');o.value=sk.id;o.textContent=`${sk.name}ï¼ˆCD${sk.cd}ï¼‰`;o.title=sk.desc;sel.appendChild(o)}); sel.value=defId||js[0].id; return sel; }
      const saved = setupData[s.id].skills||[];
      const s1=makeSkillSelect(saved[0]), s2=makeSkillSelect(saved[1]||js[Math.min(1,js.length-1)].id), s3=makeSkillSelect(saved[2]||js[Math.min(2,js.length-1)].id);
      skillsBox.append(s1,s2,s3);
      tr.skillSels=[s1,s2,s3];
    }
    refreshSkillBox();
    selItem.onchange=refreshSkillBox;

    tr.innerHTML=`<td>${s.id}</td><td>${s.side==="ally"?"ç©å®¶":"é›»è…¦"}</td>`;
    const tdKind=document.createElement("td"); tdKind.appendChild(selKind);
    const tdItem=document.createElement("td"); tdItem.appendChild(selItem);
    const tdAttr=document.createElement("td"); tdAttr.appendChild(selAttr);
    const tdSoul=document.createElement("td"); tdSoul.appendChild(selSoul);
    const tdSkills=document.createElement("td"); tdSkills.appendChild(skillsBox);
    tr.append(tdKind,tdItem,tdAttr,tdSoul,tdSkills); setupRowsEl.appendChild(tr);
    tr.dataset.slot=s.id; tr.kindSel=selKind; tr.itemSel=selItem; tr.attrSel=selAttr; tr.soulSel=selSoul;
  }
  setup.style.display="flex";
}
function mkSelect(list,val,labeler){const s=document.createElement("select"); list.forEach(x=>{const o=document.createElement("option");o.value=x;o.textContent=labeler?labeler(x):x;s.appendChild(o)}); s.value=val; return s;}
function applySetup(){
  GRID_W=Math.min(20,Math.max(6,parseInt(document.getElementById('mapW').value||GRID_W,10)));
  GRID_H=Math.min(20,Math.max(6,parseInt(document.getElementById('mapH').value||GRID_H,10)));
  document.documentElement.style.setProperty('--w', GRID_W); document.documentElement.style.setProperty('--h', GRID_H);
  sizeTag.textContent=`${GRID_W}Ã—${GRID_H}`;
  const rows=[...document.querySelectorAll("#setupRows tr")];
  rows.forEach(r=>{
    setupData[r.dataset.slot]={
      kind:r.kindSel.value,
      item:r.itemSel.value,
      attr:r.attrSel.value,
      soul:r.soulSel.value,
      skills:r.skillSels.map(s=>s.value)
    };
  });
  slots[3].x=GRID_W-1; slots[3].y=GRID_H-2; slots[4].x=GRID_W-2; slots[4].y=GRID_H-1; slots[5].x=GRID_W-3; slots[5].y=GRID_H-3;
}
function randomizeSetup(){
  const jobList = Object.keys(JOBS).filter(k=>!JOBS[k].isChar);
  const charList = Object.keys(JOBS).filter(k=>JOBS[k].isChar);
  const rows=[...document.querySelectorAll("#setupRows tr")];
  rows.forEach(r=>{
    const useChar = Math.random()<0.5;
    r.kindSel.value = useChar ? "è§’è‰²" : "è·æ¥­";
    r.itemSel.innerHTML="";
    (useChar ? charList : jobList).forEach(x=>{const o=document.createElement('option');o.value=x;o.textContent=x;r.itemSel.appendChild(o)});
    r.itemSel.value = (useChar?charList:jobList)[Math.floor(Math.random()* (useChar?charList.length:jobList.length))];
    // è§¸ç™¼æŠ€èƒ½åˆ·æ–°
    r.itemSel.dispatchEvent(new Event('change'));
    // éš¨æ©Ÿå±¬æ€§èˆ‡é­‚çŸ³
    const A=ATTR, S=Object.keys(SOULSTONES);
    r.attrSel.value=A[Math.floor(Math.random()*A.length)];
    r.soulSel.value=S[Math.floor(Math.random()*S.length)];
  });
}

/* ===================== æ§åˆ¶ / å•Ÿå‹• ===================== */
document.getElementById("reset").onclick=()=>newGame();
document.getElementById("endAct").onclick=()=>{ if(selected && selected.side==="ally"){ endActivation(); } };
document.getElementById("toggleEdit").onclick=()=>{ EDIT_MODE=!EDIT_MODE; document.getElementById("toggleEdit").textContent=`åœ°å½¢ç·¨è¼¯ï¼š${EDIT_MODE?'é–‹':'é—œ'}`; };

function seedUnits(){ units=slots.map(mkUnit); }
function newGame(){
  seedUnits(); initBlocks(); terrains=[]; selected=null; phase="idle"; round=1; roundEl.textContent=round;
  render(); logEl.innerHTML=""; log("é–‹å§‹ï¼šä½ å¯ä»»é¸æœªè¡Œå‹•å–®ä½ã€‚"); battleStart();
}

/* ===================== æ¸¬è©¦ï¼ˆé‡é»é©—è­‰ï¼‰ ===================== */
function runSmokeTests(){
  // å±¬æ€§å…‹åˆ¶
  console.assert(elemMul('ç¥','å†°')===1.25,"ç¥å…‹å†°");
  console.assert(elemMul('ç¥','å…‰')===0.8,"ç¥è¢«å…‰");
  // setActionStart / rollback
  const tempU={id:'X',x:1,y:1,actionStart:{x:0,y:0},hasMoved:true,bonusMove:2,tags:{moved2:1},hasActed:false};
  rollbackToActionStart(tempU);
  console.assert(tempU.x===0 && tempU.y===0,"rollbackToActionStart works");
  // åˆ‡æ›å–®ä½æ™‚æœƒé‚„åŸ
  selected = {id:'A',side:'ally',actionStart:{x:2,y:2},x:5,y:5,hasMoved:true,bonusMove:1,tags:{moved2:1},hasActed:false};
  onUnitClick({id:'B',side:'ally'}); // æœƒè§¸ç™¼é‚„åŸ
  // æŠ€èƒ½å¤±æ•—ä¸æ¶ˆè€—è¡Œå‹•
  const u = {id:'U',side:'ally',cd:{},hasActed:false,tags:{},soul:{hooks:{} } };
  selected=u; alliesLeft.add('U');
  const fakeSkill = { id:'_fail_', name:'å‡å¤±æ•—', type:'self', cd:3, use:()=>false };
  useSkill(u, u, fakeSkill);
  console.assert(u.hasActed===false, "æŠ€èƒ½å¤±æ•—ä¸æ‡‰æ¶ˆè€—è¡Œå‹•/æ‰“å‹¾");
}
newGame(); runSmokeTests();
</script>
</body>
</html>
